\chapter{Labo 2 : Analyser des propriétés temporelles de la cible}

% contexte

\section{Exercice 1}

Dans cet exercice, nour prenons le code qui donne les nombre premiers jusqu'à une valeur maximum sur Moodle. Ce programme n'est pas optimisé, mais nous l'exécutons pour plusieurs valeurs maximales en calculant le temps d'exécution avec le programme \texttt{time}.


\begin{lstlisting}[language=bash]
  make
  make install
  time ./prim
\end{lstlisting}

Nous améliorons ensuite l'algorithme et faisons les mêmes calculs. \\ 

\textbf{Première amélioration :} dès qu'on trouve le nombre premier pour une valeur, on passe à la suivante en ajoutant un \texttt{break}. \\

\textbf{Deuxième amélioration :} on cherche les nombres premiers de 2 jusqu'à la racine du nombre max au lieu de calculer jusqu'au bout. L'ordre de complexité passe de $0(N^2)$ à $0(N^{3/2})$. \\

\textbf{Troisième amélioration :} Une version optimisée de l'algorithme, soit la combinaison des deux premières améliorations. \\

Nous avons ensuite mesuré les temps d'exécution pour la solution de base et pour les différentes améliorations. 

\newpage

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\linewidth]{img/graph_ex1.png}
  \caption{Temps de calcul des nombres premiers, affichage logarithmique}
  \label{graph1}
\end{figure}

On remarque que les optimisations sont très efficaces et réduisent considérablement le temps de calcul. La première amélioration réduit d'un facteur fixe les calculs. La deuxième, elle, change l'ordre de complexité de l'algorithme, son facteur d'amélioration augmente donc en fonction du nombre maximum. \\

\newpage

\section{Exercice 2}
Nous ajoutons ensuite des routines bloquantes pour voir le comportement temporel du programme. Pour cet exercice nous utilisons la version du programme avec les deux améliorations faites à l'exercice 1. \\

Les mesures sont faites sur ces différents cas : aucune écriture ni autre méthode bloquante, avec un écriture sur la console, avec écriture dans la console et dans un fichier.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\linewidth]{img/graph_ex2.png}
  \caption{Temps d'exécution du programme avec et sans fonctions blocantes}
  \label{graph1}
\end{figure}

\newpage

\section{Exercice 3}
Ici nous utilisons le programme \texttt{``yes''}. Ce programme écrit des strings sur la sortie standard de manière indéfinie (jusqu'à ce que le programme soit tué) et utilise le CPU à 100\%. Nous allons donc créer des processus de \texttt{``yes''} avec une redirection dans \texttt{``/dev/null''} pour ne pas voir les caractères à l'écran. Voici la commande :

\begin{lstlisting}[language=bash]
  yes > /dev/null &
\end{lstlisting}

Nous faisons le test de lancer notre programme \texttt{``prim''} tout seul, avec un processus \texttt{``yes''}, puis avec deux processus \texttt{``yes''} qui tournent. Cela va charger le processeur et laisser moins de place au processus de notre programme. 

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\linewidth]{img/graph_ex3A.png}
  \caption{Temps d'exécution du programme avec différents processus en parallèle}
  \label{graph1}
\end{figure}


\newpage

\section{Exercice 4}
Nous changeons ensuite la \textit{nice-value} de notre programme (en laissant les processus \texttt{``yes''} tourner), pour voir l'influence de la valeur de priorité sur le temps d'exécution du programme. Pour lancer le programme en spécifiant la \textit{nice-value}, en calculant le temps d'exécution et en background, on utilise la commande suivante :

\begin{lstlisting}[language=bash]
  time nice -n 10 ./prim &
\end{lstlisting}

Pour changer la priorité, nous avons utilisé le programme \texttt{``nice''}. Les priorités vont de -20 à 19, -20 étant la plus haute priorité et 19 la plus basse.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\linewidth]{img/graph_ex3B.png}
  \caption{Temps d'exécution du programme avec différentes nice values}
  \label{graph1}
\end{figure}

Nous changeons ensuite le \textit{scheduler} de notre programme. En effet, chaque programme peut avoir son propre scheduler. Nous avons testé le scheduler FIFO premièrement.

Une façon de changer le scheduler est la suivante (sans oublier de rajouter l'include suivant : \texttt{\#include <sched.h>}) :

\begin{lstlisting}[language=c]
  struct sched_param sp;
  sp.sched_priority = sched_get_priority_max(SCHED_FIFO);
  sched_setscheduler(getpid(),SCHED_FIFO,&sp);
\end{lstlisting}

Ce code va définir le scheduler FIFO pour le process du programme et va définir la priorité à 99, qui est la plus haute priorité pour un scheduler ``temps réel'' (FIFO ou Round Robin).
Si tous les processus utilisent le scheduler standard sauf un, qui utilise un scheduler temps réel. Seul ce processus aura la main. Si plusiseurs processus sont en FIFO, seul celui avec la plus haute priorité aura la main. Si deux ont la même priorité, le premier l'emporte. Par contre si on est en Round Robin, deux processus avec la même priorité se partageront le CPU, au détriment de tous les autres processus.





