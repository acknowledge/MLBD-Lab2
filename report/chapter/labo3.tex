\chapter{Labo 3 : Optimisation d'une application}

%contexte
Le but de ce laboratoire est d'optimiser une application utilisant une caméra. La caméra filme et l'image est affichée sur l'écran. Dans la version fournie, le temps de réponse est très lent, de l'ordre de la seconde, et le processus utilise  98\% du CPU. Nous voyons sur la capture d'écran de la figure \ref{labo7_1_conso} son utilisation de CPU.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\linewidth]{img/labo7_1_conso.png}
  \caption{Consommation de CPU pour l'application de base (voir capture)}
  \label{labo7_1_conso}
\end{figure}

\noindent Nous allons donc utiliser des outils de profiling pour trouver ce qui peut être optimisé.

\newpage

\section{Mise en place des outils}

Il faut d'abord dire à la cible où trouver l'écran, pour cela il faut ajouter un paramètre dans le bios de cette manière :

\begin{lstlisting}[language=bash]
  setenv extrabootargs video=imxfb:Chimei-LW700A9003
  saveenv
\end{lstlisting}

\noindent Si tout s'est bien passé, nous voyons un pinguin sur l'écran au démarrage de la cible.

\noindent Il faut ensuite charger le pilote pour la caméra avec la commande :

\begin{lstlisting}[language=bash]
  modprobe uvcvideo
\end{lstlisting}

Nous pouvons automatiser le chargement du pilote en créant un fichier contenant le nom du pilote au bon endroit et en lui donnant les droits d'exécution. Voici comment le faire :

\begin{lstlisting}[language=bash]
  cd /etc/init.d
  echo "modprobe uvcvideo" >> S70cameradriver
  chmod 777 S70cameradriver
\end{lstlisting}

Ensuite nous devons indiquer au programme les paramètres de l'écran. Cette commande est a exécuter sur la cible :

\begin{lstlisting}[language=bash]
  fbset > /etc/fb.modes
\end{lstlisting}

Ensuite il reste à trouver le programme \texttt{capture}. Il faut le compiler et le lancer sur la cible pour activer la caméra, filmer et mettre le résultat sur l'écran. Cette version est très lente, il va falloir l'optimiser.

Pour installer des outils d'optimisation et de profiling, il faut aller dans un utilitaire qui indique quel module charger et compiler dans le noyau.
Pour ce faire, taper \texttt{make menuconfig}, aller dans \texttt{Target Packages}, ensuite \texttt{Debugging, profiling and benchmark} et activer, par exemple, \texttt{oprofile}.

Ensuite il faut recompiler le noyau avec un simple \texttt{make}. Attention à ne pas faire de \texttt{make clean}, ce qui supprime tout ce qui a déjà été compilé. Si on fait ça, on devrait TOUT recompiler et ça prend beaucoup de temps (plus d'une heure). C'est ce que nous avons fait et qui nous a fait perdre beaucoup de temps durant ce laboratoire.

Une fois le noyau compilé avec ce qu'on a besoin, il faut charger ce nouveau noyau à l'endroit où la cible va le chercher au moment du boot :

\begin{lstlisting}[language=bash]
  cp ~/workspace/buildroot/output/images/apf27-linux.bin /tftpboot/
  cp ~/workspace/buildroot/output/images/rootfs.tar /tftpboot/apf27-root
  cd /tftpboot/apf27-root
  tar xvf rootfs.tar
\end{lstlisting}

Nous rebootons ensuite la cible et le nouveau noyau est chargé. Nous pouvons commencer alors le profiling.

\section{Analyse avec oprofile}

Avec \texttt{oprofile}, il suffit de démarrer l'utilitaire, ensuite on fait tourner notre programme un moment, ensuite on l'arrête, on stop églament l'utilitaire et on demande à afficher le rapport. Voici un exemple de la démarche :


\begin{lstlisting}[language=bash]
  opcontrol --start
  ./capture
  CTRL+C
  opcontrol --stop
  opcontrol -l
\end{lstlisting}

Le \texttt{``opcontrol -l''} nous sort des statistiques sur ce qui a pris beaucoup de temps. Voici ce que ça nous donne la première fois sur le programme non optimisé :

\begin{lstlisting}[language=bash]
  # opreport -l                                                                   
  Using /var/lib/oprofile/samples/ for samples directory.                         
  warning: /no-vmlinux could not be found.                                        
  CPU: CPU with timer interrupt, speed 298 MHz (estimated)                        
  Profiling through timer interrupt                                               
  samples  %        app name                 symbol name                          
  4618     86.1085  no-vmlinux               /no-vmlinux                          
  238       4.4378  capture                  __adddf3                             
  133       2.4800  capture                  __aeabi_dmul                         
  82        1.5290  capture                  YUV2G                                
  56        1.0442  capture                  __aeabi_i2d                          
  53        0.9883  capture                  YUV2R                                
  51        0.9510  capture                  YUV2B                                
  44        0.8204  capture                  yuv422_to_rgb565                     
  32        0.5967  capture                  __fixdfsi                            
  28        0.5221  libc-2.18.so             /lib/libc-2.18.so                    
  10        0.1865  ld-2.18.so               /lib/ld-2.18.so                      
  8         0.1492  busybox                  /bin/busybox                         
  8         0.1492  libSDL-1.2.so.0.11.4     /usr/lib/libSDL-1.2.so.0.11.4        
  2         0.0373  capture                  __aeabi_dsub
\end{lstlisting}

On voit que ce qui prend beaucoup de pourcentage ce sont les méthodes \texttt{YUV2G()}, \texttt{YUV2R()}, \texttt{YUV2B()} et \texttt{yuv422\_to\_rgb565()}. De plus nous aperçevons \texttt{\_\_adddf3} qui correspond à l'addition de deux \texttt{doubles} et \texttt{\_\_aeabi\_dmul} qui correspond à la multiplication de deux \texttt{doubles}. Il faut donc optimiser ceci dans notre code.

\newpage
\section{Optimisations}

\subsection{Valeurs flottantes}

Nos cherchons donc dans le code les endroits où on additionne ou multiplie des valeurs flottantes. Nous les remplaçons par des entiers qui sont des puissances de 2 proches, nous faisons les opérations (additions, multiplications) et à la fin nous shiftons la valeurs du nombre de bit adéquat pour retrouver le bon résultat.


\noindent Après avoir fait ces optimisations, nous relançons \texttt{oprofile} pour voir ce que ça donne.


\begin{lstlisting}[language=bash]
  # opreport -l
  Using /var/lib/oprofile/samples/ for samples directory.
  warning: /no-vmlinux could not be found.
  CPU: CPU with timer interrupt, speed 298 MHz (estimated)
  Profiling through timer interrupt
  warning: the last modified time of the binary file does not match that of the sa
  mple file for /home/capture
  Either this is the wrong binary or the binary has been modified since the sample
   file was created.
  samples  %        app name                 symbol name
  11372    73.5053  no-vmlinux               /no-vmlinux
  1018      6.5801  capture                  yuv422_to_rgb565
  604       3.9041  capture                  YUV2G
  479       3.0961  capture                  YUV2B
  463       2.9927  capture                  YUV2R
  442       2.8570  capture                  __adddf3
  391       2.5273  capture                  __aeabi_dmul
  360       2.3269  libc-2.18.so             /lib/libc-2.18.so
  96        0.6205  capture                  __floatunsidf
  65        0.4201  capture                  yuv420_to_rgb565
  63        0.4072  capture                  _fini
  42        0.2715  busybox                  /bin/busybox
  39        0.2521  ld-2.18.so               /lib/ld-2.18.so
  25        0.1616  libSDL-1.2.so.0.11.4     /usr/lib/libSDL-1.2.so.0.11.4
  4         0.0259  oprofiled                /usr/bin/oprofiled
  3         0.0194  capture                  __aeabi_i2d
  2         0.0129  capture                  __divdf3
  1         0.0065  capture                  __aeabi_ul2d
  1         0.0065  capture                  __floatdidf
  1         0.0065  capture                  process_image
\end{lstlisting}

Nous ne voyons pas de gros changements dans les éléments qui prennent beaucoup de temps. Par contre nous avons une nette amélioration lors de l'exécution du programme. La vidéo retransmise sur l'écran a beaucoup moins de retard qu'au début. Le retard est presque imperceptible.


Nous pouvons également optimiser la compilation en ajoutant des CFLAGS dans le Makefile, pour compiler avec les paramètes \texttt{-O1}, \texttt{-O2} ou \texttt{-O3}. Nous avons utilisé l'optimisation \texttt{-Ofast} qui nous a donné les meilleurs résultats. 

\newpage

\subsection{Sleep}
En lançant le programme, même optimisé avec les nombres entiers, l'outil top nous indique qu'il consomme plus de 80\% du CPU, ce qui est énorme

\begin{figure}[h]
  \centering
    \includegraphics[width=0.7\linewidth]{img/labo7_82.png}
  \caption{Consommation de CPU pour l'application sans sleep}
  \label{labo7_82}
\end{figure}

Afin de baisser la consommation, on utilise un safeSleep qui va endormi le programme entre chaque frame, permettant de descendre la consommation du CPU.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.7\linewidth]{img/labo7_41.png}
  \caption{Consommation de CPU pour l'application avec sleep}
  \label{labo7_41}
\end{figure}

grâce à un sleep d'environ 80ms, on voit que le programme n'occupe plus que 40\% du processeur. Malheureusement cette optimisation de la consommation n'est pas sans effet sur la latence et le nombre d'images par secondes. On se retrouve en effet avec une affichage moins fluide et avec plus de décalage. C'est le prix à payer pour avoir une consommation plus faible. 

Le décalage est de 500ms.

\section{Résultat}

Le programme final est plus fluide et possède un décalage plus faible que le programme de base, grâce notamment à l'utilisation de valeur entière pour les calculs de conversion de format YUV et RGB. Il consomme également beaucoup moins de ressouces, n'occupant plus que 40\% du CPU.

%\begin{figure}[h]
%  \centering
%    \includegraphics[width=0.8\linewidth]{img/labo7_2_conso.png}
%  \caption{Consommation de CPU pour l'application de base (voir capture)}
%  \label{labo7_2_conso}
%\end{figure}


